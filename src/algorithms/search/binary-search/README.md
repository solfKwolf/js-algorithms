# 二分搜索

## 原理 二分搜索技术

例如，给定有n个元素的序列，这些元素是有序的（假定为升序），从序列中查找元素x。

用一维数组S[]存储该有序序列，设变量low和high表示查找范围的下界和上界，middle表示查找范围的中间位置，x表示特定的查找元素。

1. 算法步骤

（1）初始化。令low=0，即指向有序数组`S[]`的第1个元素；high=n−1，即指向有序数组`S[]`的最后一个元素。

（2）判定low≤high是否成立，如果成立，则转向步骤3，否则算法结束。

（3）middle=(low+high)/2，即指向查找范围的中间元素。如果数量较大，则为避免low+high溢出，可以采用middle=low+(high-low)/2。

（4）判断x与S[middle]的关系。如果x=S[middle]，则搜索成功，算法结束；如果x>S[middle]，则令low=middle+1；否则令high=middle−1，转向步骤2。


## 算法分析

+ 时间复杂度

二分查找的非递归算法和递归算法查找的方法是一样的，时间复杂度相同，均为O(logn)。

+ 空间复杂度

在二分查找的非递归算法中，变量占用了一些辅助空间，这些辅助空间都是常数阶的，因此空间复杂度为O(1)。

二分查找递归算法的空间复杂度为O(logn)。


在二分搜索中需要注意以下几个问题。

（1）必须满足有序性

（2）搜索范围。初始时，需要指定搜索范围，如果不知道具体范围，则对正数可以采用范围[0,inf]，对负数可以采用范围[-inf,inf]，inf为无穷大，通常设定为0x3f3f3f3f。

（3）二分搜索。在一般情况下，mid=(l+r)/2或mid=(l+r)>>1。如果l和r特别大，则为了避免l+r溢出，可以采用mid=l+(r-l)/2。对判断二分搜索结束的条件，以及判断mid可行时是在前半部分搜索，还是在后半部分搜索，需要具体问题具体分析。

（4）答案是什么。在减少搜索范围时，要特别注意是否漏掉了mid点上的答案。
